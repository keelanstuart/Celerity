var runtime;

var hobj_root = -1;

var i = 0;
var tmp = 0.0;
var tmpv3 = { x: 0.0, y: 0.0, z:0.0 };
var tmpv4 = { x: 0.0, y: 0.0, z:0.0, w: 0.0 };

var delta_ori = { x: 0.0, y: 0.0, z:0.0, w: 0.0 };
var target_ori = { x: 0.0, y: 0.0, z:0.0, w: 0.0 };

var local_right = { x: 1.0, y: 0.0, z:0.0 };
var local_forward = { x: 0.0, y: 1.0, z:0.0 };
var local_up = { x: 0.0, y: 0.0, z:1.0 };

var mousepos = { x: 0, y: 0 };
var aim_vec = { x: 0.0, y: 0.0, z: 0.0 };

var hobj_parent;
var hobj_thrust;

var hprop_facing = { forward: -1, right: -1, up: -1 };

var hprop_pos;
var hprop_ori;
var hprop_lvel;
var hprop_rvel;

var lacc_accum = { x: 0.0, y: 0.0, z: 0.0 };
var lvel_accum = { x: 0.0, y: 0.0, z: 0.0 };
var rvel_accum = { x: 0.0, y: 0.0, z: 0.0 };
var ori = { x: 0.0, y: 0.0, z: 0.0, w: 0.0 };
var pos = { x: 0.0, y: 0.0, z: 0.0 };

var speed_max = 100.0;
var speed_min = -20.0;
var speed_step = 5.0;
var speed = 0.0;

var boost_time_max = 10.0;
var boost_time = 0.0;
var boost = 0;
var boost_recharge = 0.3;

var thruster_strength = 10.0;
var turn_speed = Math.toRadians(100.0);
var roll_speed = Math.toRadians(5000.0);

var collision_info;

var bullet_idx = 0;
var bullet_max = 20;
var hobj_bullet = [];
var bpos = { x: 0.0, y: 0.0, z:0.0 };
var bvel = { x: 0.0, y: 0.0, z:0.0 };
var bullet_cooldown_max = 0.33;
var bullet_cooldown = 0.0;

var hsound_engine = -1;

var missile_idx = 0;
var missiles_max = 4;
var hobj_missile = [];

function update(elapsed_seconds)
{
	runtime += elapsed_seconds;
	
	if (boost)
		boost_time += elapsed_seconds;
	else if (boost_time > 0.0)
		boost_time -= (elapsed_seconds * boost_recharge);
		
	if (boost_time > boost_time_max)
	{
		boost = 0;
		boost_time = boost_time_max;
	}
	else if (boost_time < 0.0)
		boost_time = 0.0;

	if (boost == 0)
	{
		speed = Math.range(speed, speed_min, speed_max);
		lvel_accum.y = speed;
	}
	else
	{
		lvel_accum.y = speed_max * 3.0;
	}

	local_right = GetPropertyValue(hprop_facing.right);
	local_forward = GetPropertyValue(hprop_facing.forward);
	local_up = GetPropertyValue(hprop_facing.up);

	ori = GetPropertyValue(hprop_ori);

	mousepos = GetMousePos();
	aim_vec = Vec3.normalize(Unproject(mousepos));

	tmp = Vec3.dot(aim_vec, local_forward);
	//Execute(hobj_root, "update_cursor(" + tmp + ");");

	// steering the ship is done with the mouse position...
	// get the quaternion that takes you from the current
	// facing vector to the mouse vector, then slerp to that
	delta_ori  = QuatFromTo(local_forward, aim_vec);
	target_ori = Quat.mul(delta_ori, ori);

	// slerp toward final target
	ori = Math.slerp(ori, target_ori, Math.min(elapsed_seconds * turn_speed, 1.0));

	// do roll separately
	delta_ori = AxisAngleToQuat(aim_vec, rvel_accum.y);
	target_ori = Quat.mul(delta_ori, ori);

	// ...ignore turn_speed here, since we've already take it into account
	ori = Math.slerp(ori, target_ori, Math.min(elapsed_seconds, 1.0));

	SetPropertyValue(hprop_ori, ori);

	if (hsound_engine >= 0)
	{
		tmpv3 = GetListenerPosition();
		SetSoundPosition(hsound_engine, tmpv3);
		SetSoundPitchMod(hsound_engine, (speed / speed_max) / 2.0 + 0.5);
	}

	if (lvel_accum.y <= 0.0)
		SetObjFlag(hobj_thrust, "DRAW", 0);
	else
		SetObjFlag(hobj_thrust, "DRAW", 1);
	
	// adjust the linear velocity and orientation based on accumulated inputs
	SetPropertyValue(hprop_lvel, lvel_accum);

	// clear the accumulators after each update
	lvel_accum.x = 0.0;	lvel_accum.y = 0.0;	lvel_accum.z = 0.0;
	rvel_accum.x = 0.0;	rvel_accum.y = 0.0;	rvel_accum.z = 0.0;

	boost = 0;
	
	bullet_cooldown -= elapsed_seconds;
}

function handle_input(action, value)
{
	if (action == "Strafe Left")
	{
		lvel_accum.x -= (thruster_strength * value);
	}
	else if (action == "Strafe Right")
	{
		lvel_accum.x += (thruster_strength * value);
	}
	else if (action == "Ascend")
	{
		lvel_accum.z += (thruster_strength * value);
	}
	else if (action == "Descend")
	{
		lvel_accum.z -= (thruster_strength * value);
	}
	else if (action == "Look Up")
	{
	}
	else if (action == "Look Down")
	{
	}
	else if (action == "Look Left")
	{
	}
	else if (action == "Look Right")
	{
	}
	else if (action == "Roll Right")
	{
		rvel_accum.y += (roll_speed * value);
	}
	else if (action == "Roll Left")
	{
		rvel_accum.y -= (roll_speed * value);
	}
	else if (action == "Increase Velocity")
	{
		speed += speed_step;
	}
	else if (action == "Decrease Velocity")
	{
		speed -= speed_step;
	}
	else if (action == "Boost")
	{
		boost = 1;
	}
	else if ((action == "Fire 1") && (bullet_cooldown <= 0.0))
	{
		bullet_cooldown = bullet_cooldown_max;

		bpos = GetPropertyValue(hprop_pos);
		bvel = Vec3.mul(aim_vec, 1000.0);

		local_right = GetPropertyValue(hprop_facing.right);
		local_forward = GetPropertyValue(hprop_facing.forward);

		tmpv3 = Vec3.mul(local_right, -1.9);
		tmpv3 = Vec3.madd(local_forward, 2.0, tmpv3);
		tmpv3 = Vec3.add(bpos, tmpv3);
		Execute(hobj_bullet[bullet_idx], "fire(" + tmpv3.x + "," + tmpv3.y + "," + tmpv3.z + "," + bvel.x + "," + bvel.y + "," + bvel.z + ");");
		bullet_idx = (bullet_idx + 1) % bullet_max;

		tmpv3 = Vec3.mul(local_right, 1.9);
		tmpv3 = Vec3.madd(local_forward, 2.0, tmpv3);
		tmpv3 = Vec3.add(bpos, tmpv3);
		Execute(hobj_bullet[bullet_idx], "fire(" + tmpv3.x + "," + tmpv3.y + "," + tmpv3.z + "," + bvel.x + "," + bvel.y + "," + bvel.z + ");");
		bullet_idx = (bullet_idx + 1) % bullet_max;
	}
	else if (action == "Fire 2")
	{
	}
}

function init()
{
	runtime = 0.0;

	hobj_parent = GetParent(self);
	hobj_thrust = FindFirstObjByName(self, "ThrustEffects", 0);

	hobj_root = self;
	var found = 0;
	while (found == 0)
	{
		Log(GetObjectName(hobj_root));

		tmp = GetParent(hobj_root);
		if (tmp > 0)
		{
			hobj_root = tmp;
			Log(" <- ");
		}
		else
			found = 1;
	}
	Log("\n");

	// cache property handles now so value access is cheaper later

	hprop_facing.right = FindProperty(self, "Facing.Right");
	hprop_facing.forward = FindProperty(self, "Facing.Forward");
	hprop_facing.up = FindProperty(self, "Facing.Up");

	hprop_pos = FindProperty(self, "Position");
	hprop_ori = FindProperty(self, "Orientation");
	hprop_rvel = FindProperty(self, "RotationalVelocity");
	hprop_lvel = FindProperty(self, "LinearVelocity");

	for (i = 0; i < bullet_max; i++)
	{
		hobj_bullet[i] = CreateObject("LaserBlast1", hobj_parent);
	}

	collision_info = CreateCollisionResults();

	tmpv3 = GetListenerPosition();
	hsound_engine = PlaySound("Protectorate/engine.wav", 1.0, 0.1, -1, tmpv3);
}

function free()
{
	FreeCollisionResults(collision_info);

	if (hsound_engine >= 0)
		StopSound(hsound_engine);
}
