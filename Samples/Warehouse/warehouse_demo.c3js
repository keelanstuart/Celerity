var runtime = 0.0;
var menu_active = 0;

// Scene + camera handles
var hobj_levelroot;
var hobj_camroot, hprop_camroot_pos, hprop_camroot_ori;
var hobj_camarm,  hprop_camarm_pos;
var hobj_cam,     hprop_cam_ori, hprop_cam_fov;
var hprop_camroot_facing, hprop_camroot_right;

var collision_info;

// Movement state
var pos       = { x:0.0, y:0.0, z:0.0 };
var vel       = { x:0.0, y:0.0, z:0.0 };
var acc       = { x:0.0, y:0.0, z:0.0 };

// Decomposed (orthogonal vs along gravity) â€” derived when needed
var grav      = { x:0.0, y:0.0, z:0.0 };
var grav_dir  = { x:0.0, y:0.0, z:0.0 }; // normalized gravity (down)

var vlat      = { x:0.0, y:0.0, z:0.0 };
var speed     = 0.0;

// Camera/controls
var cam_facing       = { x:0.0, y:0.0, z:0.0 };
var cam_right        = { x:0.0, y:0.0, z:0.0 };
var cam_facing_flat  = { x:0.0, y:0.0, z:0.0 }; // orthogonal to gravity
var cam_right_flat   = { x:0.0, y:0.0, z:0.0 }; // orthogonal to gravity

// Input state (press/release handled via explicit "Up" actions)
var running       = 0;
var crouching     = 0;
var move_forward  = 0.0;
var move_backward = 0.0;
var strafe_left   = 0.0;
var strafe_right  = 0.0;
var look_left     = 0.0;
var look_right    = 0.0;
var look_up       = 0.0;
var look_down     = 0.0;

var aiming       = 0;
var grounded     = 1;
var jumped_count = 0;    // double-jump counter (0..2 between ground contacts)

// Per-frame input accumulators (reuse to avoid garbage)
var move_acc = { x:0.0, y:0.0, z:0.0 }; // lateral accel from inputs
var jump_imp = { x:0.0, y:0.0, z:0.0 }; // one-frame vertical impulse

// Eye height (interpolated)
var walk_height   = 120.0;
var crouch_height = 60.0;
var height_targ   = walk_height;
var height        = height_targ;

// Capsule-ish sweep heights (forward checks are done in native code)
var low_height  = 30.0;	// above position
var high_height = 10.0; // above height

// Speeds & dynamics
var move_mult		= 1.0;
var walk_speed      = 18000.0;
var run_mult        = 2.7;
var crouch_mult     = 0.55;
var air_control     = 0.01;		// fraction of lateral accel when airborne
var ground_friction = 17000.0;	// optional lateral damping on ground
var air_friction    = 0.02;	// small lateral damping in air

// Jump
var jump_power = -26000.0;    // along gravity (grav_dir points DOWN). Negative => UP.

// Camera / FOV
var fov_normal = 62.0;
var fov_zoom   = 22.0;
var fov_targ   = fov_normal;
var fov        = fov_targ;

// Look deltas (applied each frame)
var body_zrot = 0.0;
var head_xrot = 0.0;
var xaxis     = { x:1.0, y:0.0, z:0.0 };
var zaxis     = { x:0.0, y:0.0, z:1.0 };
var tmpori    = { x:0.0, y:0.0, z:0.0, w:1.0 };
var tmppos    = { x:0.0, y:0.0, z:0.0 };
var tmpvec    = { x:0.0, y:0.0, z:0.0 };
var tmp       = 0.0;

var setup = 1;


function init()
{
	runtime = 0.0;
	
	var cur = RegisterCursor("default_cursor_sm.tga", {x:3, y:2}, "Default");
	SetCursor(cur);

	EnableMouse(0);
	EnableSystemMouse(0);
	CaptureMouse(1);
	
	hobj_levelroot = CreateObject("", self);
	var load_result = LoadObject(hobj_levelroot, "Warehouse/Warehouse.c3o");
	if (load_result["success"] == 1)
		Log("Level loaded.\n");
	else
		Log("Level failed to load!\n");

	hobj_guiroot = GetRegisteredObject("gui.root");
	hobj_mainmenu = CreateObject("", hobj_guiroot);
	LoadObject(hobj_mainmenu, "Warehouse/MainMenu.c3o");
	SetObjFlag(hobj_mainmenu, "UPDATE", menu_active);
	SetObjFlag(hobj_mainmenu, "DRAW", menu_active);
	if (load_result["success"] == 1)
		Log("Main menu loaded successfully!\n");
	else
		Log("Main menu failed to load!\n");

	hobj_camroot = GetRegisteredObject("camera.root");
	hobj_camarm  = GetRegisteredObject("camera.arm");
	hobj_cam     = GetRegisteredObject("camera");
	
	hprop_camroot_pos = FindProperty(hobj_camroot, "Position");
	hprop_camroot_ori = FindProperty(hobj_camroot, "Orientation");
	hprop_camarm_pos  = FindProperty(hobj_camarm , "Position");
	
	hprop_cam_ori      = FindProperty(hobj_cam, "Orientation");
	var hprop_cam_minp = FindProperty(hobj_cam, "PitchCameraAngleMin");
	var hprop_cam_maxp = FindProperty(hobj_cam, "PitchCameraAngleMax");
	hprop_camroot_facing = FindProperty(hobj_camroot, "Facing.Forward");
	hprop_camroot_right  = FindProperty(hobj_camroot, "Facing.Right");
	
	SetPropertyValue(hprop_cam_minp, -88.0);
	SetPropertyValue(hprop_cam_maxp,  88.0);
	
	hprop_cam_fov       = FindProperty(hobj_cam, "FOV(Perspective)");
	var hprop_cam_orbit = FindProperty(hobj_cam, "OrbitDistance");
	var hprop_cam_far   = FindProperty(hobj_cam, "FarClip");
	SetPropertyValue(hprop_cam_far, 20000.0);
	SetPropertyValue(hprop_cam_orbit, 0.01);
	
	tmppos = { x:0, y:0, z:height };
	SetPropertyValue(hprop_camarm_pos, tmppos);
	
	collision_info = CreateCollisionResults();
	
	// -------- Input actions --------
	// Press events
	RegisterInputAction("Run", "delta", 0.0);
	RegisterInputAction("Crouch", "delta", 0.0);
	RegisterInputAction("Jump", "", 0.0);
	RegisterInputAction("Move Forward", "", 0.0);
	RegisterInputAction("Move Backward", "", 0.0);
	RegisterInputAction("Strafe Left", "", 0.0);
	RegisterInputAction("Strafe Right", "", 0.0);
	RegisterInputAction("Aim", "", 0.0);
	RegisterInputAction("Look Up", "", 0.0);
	RegisterInputAction("Look Down", "", 0.0);
	RegisterInputAction("Look Left", "", 0.0);
	RegisterInputAction("Look Right", "", 0.0);
	RegisterInputAction("Quit", "up", 0.0);
}

// ---------- Init / Respawn ----------
function respawn()
{
	jumped_count = 0;
	running = 0;
	crouching = 0;

	var spawn;
	if (Math.random(0, 10) < 5)
		spawn = "SPAWN1";
	else
		spawn = "SPAWN2";

	var hobj_spawn = FindFirstObjByName(hobj_levelroot, spawn, 1);
	
	var hprop_spawn_pos = FindProperty(hobj_spawn, "Position");
	var hprop_spawn_ori = FindProperty(hobj_spawn, "Orientation");
	
	tmppos = GetPropertyValue(hprop_spawn_pos);
	SetPropertyValue(hprop_camroot_pos, tmppos);
	
	tmpori = GetPropertyValue(hprop_spawn_ori);
	SetPropertyValue(hprop_camroot_ori, tmpori);
	
	pos = tmppos;
	vel = { x:0.0, y:0.0, z:0.0 };
	acc = { x:0.0, y:0.0, z:0.0 };

	height_targ	= walk_height;	
	height = height_targ;

	Log("Spawned at: " + spawn + " (" + tmppos.x + ", " + tmppos.y + ", " + tmppos.z + ")\n");
}

function first_update()
{
	respawn();
}

// ---------- Main update ----------
function update(elapsed_seconds)
{
	if (setup == 1)
	{
		setup = 0;
		elapsed_seconds = 0.0;
		first_update();
	}

	runtime += elapsed_seconds;

	// Gravity & camera bases
	grav = GetGravity();
	grav_dir = Vec3.normalize(grav);
	
	cam_facing = GetPropertyValue(hprop_camroot_facing);
	cam_right  = GetPropertyValue(hprop_camroot_right);

	cam_facing_flat = Vec3.normalize(Vec3.reject(cam_facing, grav_dir));
	cam_right_flat  = Vec3.normalize(Vec3.reject(cam_right,  grav_dir));
	
	// Eyepoint + FOV smoothing
	if (crouching == 0)
		height_targ = walk_height;
	else
		height_targ = crouch_height;

	if (aiming == 0)
		fov_targ = fov_normal;
	else
		fov_targ = fov_zoom;

	fov    = Math.lerp(fov, fov_targ, elapsed_seconds * 20.0);
	height = Math.lerp(height, height_targ, elapsed_seconds * 20.0);
	
	// Build lateral acceleration from input flags
	move_acc = Vec3.mul(cam_facing_flat, walk_speed * (move_forward - move_backward));
	move_acc = Vec3.madd(cam_right_flat, walk_speed * (strafe_right - strafe_left), move_acc);
	
	// Apply run/crouch to lateral accel only; reduce in air
	move_mult = 1.0;

	if (grounded == 1)
	{
		if (running == 1)
			move_mult *= run_mult;

		if (crouching == 1)
			move_mult *= crouch_mult;
	}
	else
	{
		move_mult *= air_control;
	}

	move_acc = Vec3.mul(move_acc, move_mult);
	
	// Compose vertical accel: gravity + one-frame jump impulse
	// (grav_dir points DOWN; jump_power is negative => upward)
	var vert_acc = Vec3.add(grav, jump_imp);

	// clear jump impulse after consuming
	jump_imp.x = 0.0;
	jump_imp.y = 0.0;
	jump_imp.z = 0.0;
	
	// Final per-frame acceleration vector
	acc = Vec3.add(move_acc, vert_acc);
	
	// Pull pos from camera root (engine provides current transform)
	pos = GetPropertyValue(hprop_camroot_pos);

	grounded = 0;
	// do the heavy lifting in native code (capsule-ish low/high checks, sliding, ground detect)
	if (HandleFPSMovement(hobj_levelroot, pos, vel, acc, elapsed_seconds, low_height, height + high_height) == 1)
	{
		grounded = 1;

		// Ground/air post-processing on velocity (optional friction)
		jumped_count = 0; // reset double jump
		if (ground_friction > 0.0)
		{
			vlat = Vec3.reject(vel, grav_dir);
			tmp = Vec3.length(vlat);
			if (tmp > 0.0001)
			{
				speed = Math.max(0.0, tmp - ground_friction * tmp);
				if (speed > 0.0)
					tmpvec = Vec3.mul(vlat, 1.0 / speed);
				else
					tmpvec = vlat;

				vel = Vec3.madd(tmpvec, speed, Vec3.project(vel, grav_dir));
			}
		}
		else
		{
			// keep horizontal; if you want to zero it on ground, do:
			// vel = Vec3.project(vel, grav_dir);
		}
	}
	else
	{
		if (air_friction > 0.0)
		{
			var vlatA = Vec3.reject(vel, grav_dir);
			vlatA = Vec3.mul(vlatA, Math.max(0.0, 1.0 - air_friction * elapsed_seconds));
			vel = Vec3.add(vlatA, Vec3.project(vel, grav_dir));
		}
	}

	elapsed_seconds * 

	// Write back updated position
	SetPropertyValue(hprop_camroot_pos, pos);
	
	// Apply camera look deltas

	// make looking around slower when you're zoomed
	tmp = (fov / fov_normal);
	tmp *= tmp;

	body_zrot = ((look_left - look_right) * elapsed_seconds) * tmp;

	tmpori = GetPropertyValue(hprop_camroot_ori);
	tmpori = AdjustQuat(tmpori, zaxis, Math.toRadians(body_zrot * 550.0));
	SetPropertyValue(hprop_camroot_ori, tmpori);
	
	tmpori = GetPropertyValue(hprop_cam_ori);
	tmpvec = QuatToEuler(tmpori);
	head_xrot = (look_down - look_up) * elapsed_seconds * tmp;

	tmpori = GetPropertyValue(hprop_cam_ori);
	tmpori = AdjustQuat(tmpori, xaxis, Math.toRadians(head_xrot * 490.0));
	SetPropertyValue(hprop_cam_ori, tmpori);
	
	// Eyepoint height & FOV writeback
	tmppos = { x:0.0, y:0.0, z:height };
	SetPropertyValue(hprop_camarm_pos, tmppos);
	SetPropertyValue(hprop_cam_fov, fov);
}


function enable_menu(enabled)
{
	menu_active = enabled;
	SetObjFlag(hobj_levelroot, "UPDATE", menu_active ^ 1);
	SetObjFlag(hobj_mainmenu, "UPDATE", menu_active);
	SetObjFlag(hobj_mainmenu, "DRAW", menu_active);
	EnableMouse(menu_active);
	CaptureMouse(menu_active ^ 1);
}


// ---------- Input ----------
function handle_input(action, value)
{
	if (action == "Run")
	{
		if (value > 0.5)
			running = 1;
		else
			running = 0;
	}
	else if (action == "Crouch")
	{
		if (value > 0.5)
			crouching = 1;
		else
			crouching = 0;
	}
	else if (action == "Move Forward")
	{
		move_forward = value;
	}
	else if (action == "Move Backward")
	{
		move_backward = value;
	}
	else if (action == "Strafe Left")
	{
		strafe_left = value;
	}
	else if (action == "Strafe Right")
	{
		strafe_right = value;
	}
	else if (action == "Aim")
	{
		if (value > 0.5)
			aiming = 1;
		else
			aiming = 0;
	}
	else if (action == "Jump")
	{
		// Allow two jumps between ground contacts
		if (jumped_count <= 1)
		{
			jump_imp = Vec3.madd(grav_dir, jump_power, jump_imp);
			jumped_count += 1;
		}
	}
	// Mouse look (accumulate; applied in update)
	else if (action == "Look Left")
	{
		look_left = value;
	}
	else if (action == "Look Right")
	{
		look_right = value;
	}
	else if (action == "Look Up")
	{
		look_up = value;
	}
	else if (action == "Look Down")
	{
		look_down = value;
	}
	else if (action == "Quit")
	{
		enable_menu(menu_active ^ 1);
	}
}


// This is called at start-up and when a new device is detected
function device_connected(device_type, device_name, naxes, nbuttons)
{
	Log("Registering " + device_name + " Controls... ");

	if (device_type == "keyboard")
	{
		LinkInputToAction("Run", device_name, "l shift");
		LinkInputToAction("Strafe Left", device_name, "a");
		LinkInputToAction("Strafe Right", device_name, "d");
		LinkInputToAction("Move Forward", device_name, "w");
		LinkInputToAction("Move Backward", device_name, "s");
		LinkInputToAction("Jump", device_name, "button 3");
		LinkInputToAction("Crouch", device_name, "l ctrl");
		LinkInputToAction("Use", device_name, "e");
		LinkInputToAction("Cycle View Mode", device_name, "select");
		LinkInputToAction("Quit", device_name, "quit");

		Log("done.\n");
	}
	else if (device_type == "mouse")
	{
		LinkInputToAction("Fire 1", device_name, "button 1");
		LinkInputToAction("Aim", device_name, "button 2");
		LinkInputToAction("Look Up", device_name, "axis 2 +y");
		LinkInputToAction("Look Down", device_name, "axis 2 -y");
		LinkInputToAction("Look Left", device_name, "axis 2 -x");
		LinkInputToAction("Look Right", device_name, "axis 2 +x");
		LinkInputToAction("Next Weapon", device_name, "axis 2 +z");
		LinkInputToAction("Prev Weapon", device_name, "axis 2 -z");

		Log("done.\n");
	}
	else if (naxes > 1)
	{
		LinkInputToAction("Run", device_name, "button 9");
		LinkInputToAction("Jump", device_name, "button 10");
		LinkInputToAction("Move Forward", device_name, "axis 1 +y");
		LinkInputToAction("Move Backward", device_name, "axis 1 -y");
		LinkInputToAction("Strafe Left", device_name, "axis 1 -x");
		LinkInputToAction("Strafe Right", device_name, "axis 1 +x");
		LinkInputToAction("Look Down", device_name, "axis 2 -y");
		LinkInputToAction("Look Up", device_name, "axis 2 +y");
		LinkInputToAction("Look Left", device_name, "axis 2 -x");
		LinkInputToAction("Look Right", device_name, "axis 2 +x");
		LinkInputToAction("Use", device_name, "button 1");
		LinkInputToAction("Aim", device_name, "button 5");
		LinkInputToAction("Fire 1", device_name, "button 6");
		LinkInputToAction("Next Weapon", device_name, "pov +x");
		LinkInputToAction("Prev Weapon", device_name, "pov -x");
		LinkInputToAction("Cycle View Mode", device_name, "button 4");

		Log("done.\n");
	}
	else
	{
		Log("device ignored.\n");
	}
}


// ---------- Shutdown ----------
function free()
{
  CaptureMouse(0);
  EnableSystemMouse(1);
  FreeCollisionResults(collision_info);
}

